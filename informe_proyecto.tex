\documentclass[12pt,a4paper]{article}

% Paquetes esenciales
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{amsmath, amssymb}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{float}
\usepackage{caption}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows, positioning}

\geometry{margin=2.5cm}

% Configuración de hipervínculos
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    citecolor=blue,
    pdftitle={Sistema IoT de Detección de Incendios},
    pdfauthor={UNSA}
}

% Configuración de listings para código
\lstdefinestyle{pythonstyle}{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{teal},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=single,
    rulecolor=\color{black!30},
    tabsize=4,
    captionpos=b,
    backgroundcolor=\color{gray!5}
}

\lstdefinestyle{cppstyle}{
    language=C++,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{teal},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=single,
    rulecolor=\color{black!30},
    tabsize=4,
    captionpos=b,
    backgroundcolor=\color{gray!5}
}

\lstset{style=pythonstyle}

% Estilos TikZ para diagramas
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=6em, text centered, rounded corners, minimum height=3em]
\tikzstyle{sensor} = [rectangle, draw, fill=green!20, 
    text width=5em, text centered, rounded corners, minimum height=2.5em]
\tikzstyle{arrow} = [thick,->,>=stealth]

\begin{document}

%=========================================================
% PORTADA
%=========================================================
\begin{titlepage}
    \centering
    \vspace*{1cm}
    
    {\large\bfseries Universidad Nacional de San Agustín de Arequipa\par}
    \vspace{0.5cm}
    {\large Facultad de Ingeniería de Producción y Servicios\par}
    {\large Escuela Profesional de Ingeniería Electrónica\par}
    
    \vspace{3cm}
    
    {\Huge\bfseries Sistema IoT de Detección de Incendios\par}
    \vspace{0.5cm}
    {\LARGE\bfseries con Análisis de Imágenes y Notificación en Tiempo Real\par}
    
    \vspace{2cm}
    
    {\Large Informe Técnico de Proyecto Final\par}
    \vspace{0.5cm}
    {\large Curso: Internet de las Cosas (IoT)\par}
    
    \vfill
    
    \begin{flushleft}
    {\large\textbf{Presentado por:}\par}
    {\large [Nombre del estudiante]\par}
    \vspace{0.3cm}
    {\large\textbf{Docente:}\par}
    {\large [Nombre del docente]\par}
    \end{flushleft}
    
    \vfill
    
    {\large Arequipa, Perú\par}
    {\large Diciembre 2025\par}
\end{titlepage}

%=========================================================
% ÍNDICE
%=========================================================
\tableofcontents
\newpage

%=========================================================
% RESUMEN
%=========================================================
\section{Resumen}

El presente proyecto implementa un sistema completo de detección temprana de incendios utilizando tecnologías del Internet de las Cosas (IoT). El sistema integra sensores físicos (temperatura, luz, humedad y presión atmosférica) montados en una placa Arduino, un servidor backend desarrollado en Python con FastAPI, una aplicación móvil basada en Android (Termux) que actúa como cámara inteligente, y un panel web de monitoreo en tiempo real.

\subsection{Funcionamiento General}

El flujo operativo del sistema es el siguiente:

\begin{enumerate}[itemsep=0.5em]
    \item El \textbf{nodo sensor Arduino} toma lecturas continuas cada 5 segundos y las transmite al servidor mediante MQTT o HTTP.
    
    \item El \textbf{servidor backend} evalúa los umbrales configurados:
    \begin{itemize}
        \item \textit{Normal}: Temperatura < 45°C y Luz < 800 lux
        \item \textit{Alerta}: Temperatura ≥ 45°C o Luz ≥ 800 lux
        \item \textit{Peligro}: Temperatura ≥ 55°C o Luz ≥ 1000 lux
    \end{itemize}
    
    \item Cuando se detecta estado de \textit{Peligro}, el servidor solicita automáticamente a la \textbf{cámara Android} la captura de \textbf{5 fotografías secuenciales} (una cada 2 segundos) mediante comando MQTT.
    
    \item Las imágenes son enviadas al servidor y almacenadas en \texttt{uploads/images/}. El sistema ejecuta un \textbf{análisis heurístico basado en color HSV} para detectar patrones rojizos/amarillentos típicos de fuego.
    
    \item Si el análisis confirma presencia de fuego (≥3\% de píxeles con características de llama), el sistema:
    \begin{itemize}
        \item Actualiza el estado global a \textit{Fuego\_Confirmado}
        \item Registra el evento en la base de datos SQLite
        \item Envía notificación automática por \textbf{Telegram} con la última fotografía capturada
    \end{itemize}
    
    \item En caso contrario, se descarta como falsa alarma y el sistema retorna a estado \textit{Normal}.
\end{enumerate}

El sistema cuenta con un \textbf{dashboard web} responsivo que muestra en tiempo real el estado del sistema, lecturas de sensores, gráficos históricos (Chart.js), registro de eventos y las últimas 5 capturas fotográficas con visualización modal.

\subsection{Tecnologías Implementadas}

\begin{itemize}[itemsep=0.3em]
    \item \textbf{Hardware}: Arduino Uno, DHT22 (temp/humedad), LDR (luz), BMP180 (presión)
    \item \textbf{Comunicación}: MQTT (HiveMQ broker), HTTP/REST API
    \item \textbf{Backend}: Python 3.12, FastAPI, SQLite, OpenCV, NumPy, Pillow
    \item \textbf{Frontend}: HTML5, CSS3, JavaScript (Chart.js para visualización)
    \item \textbf{Móvil}: Android con Termux, Python, termux-api (cámara nativa)
    \item \textbf{Notificaciones}: Telegram Bot API
    \item \textbf{IA}: Análisis heurístico HSV (preparado para integrar TFLite/Keras)
\end{itemize}

El proyecto demuestra la viabilidad de sistemas IoT de bajo costo para detección temprana de incendios, con potencial de escalabilidad y mejora mediante la integración de modelos de deep learning entrenados específicamente para detección de fuego y humo.

\newpage

%=========================================================
% ARQUITECTURA DEL SISTEMA
%=========================================================
\section{Arquitectura del Sistema}

\subsection{Diagrama de Bloques}

El sistema está compuesto por cuatro módulos principales que interactúan mediante protocolos estándar de comunicación:

\begin{figure}[H]
\centering
\begin{tikzpicture}[node distance=2.5cm, auto]
    % Nodos principales
    \node [sensor] (arduino) {Arduino + Sensores};
    \node [block, right of=arduino, xshift=2cm] (server) {Servidor Backend (FastAPI)};
    \node [sensor, below of=server, yshift=-0.5cm] (camera) {Cámara Android (Termux)};
    \node [block, right of=server, xshift=2cm] (dashboard) {Dashboard Web};
    \node [block, below of=dashboard, yshift=-0.5cm] (telegram) {Telegram Bot};
    \node [block, below of=arduino, yshift=-0.5cm] (mqtt) {MQTT Broker (HiveMQ)};
    
    % Flechas
    \draw [arrow] (arduino) -- node[anchor=south] {MQTT/HTTP} (server);
    \draw [arrow] (server) -- node[anchor=south] {HTTP} (dashboard);
    \draw [arrow] (server) -- node[anchor=west] {Solicitud} (camera);
    \draw [arrow] (camera) -- node[anchor=east] {5 Fotos} (server);
    \draw [arrow] (server) -- node[anchor=west] {Alerta} (telegram);
    \draw [arrow, dashed] (arduino) -- (mqtt);
    \draw [arrow, dashed] (mqtt) -- (server);
    \draw [arrow, dashed] (camera) -- (mqtt);
\end{tikzpicture}
\caption{Diagrama de bloques del sistema IoT de detección de incendios}
\label{fig:bloques}
\end{figure}

\subsection{Componentes del Sistema}

\subsubsection{Nodo Sensor (Arduino)}
Plataforma de adquisición de datos ambientales. Incluye:
\begin{itemize}
    \item DHT22: Sensor digital de temperatura y humedad (±0.5°C, ±2\% RH)
    \item LDR + Divisor de tensión: Medición de intensidad luminosa (0-1023)
    \item BMP180: Sensor barométrico I2C (presión atmosférica)
    \item Comunicación: MQTT pub/sub en topic \texttt{unsa/fire\_detection/sensores}
\end{itemize}

\subsubsection{Servidor Backend}
Núcleo de procesamiento y lógica de negocio. Responsabilidades:
\begin{itemize}
    \item Recepción y validación de datos de sensores
    \item Evaluación de umbrales en tiempo real
    \item Gestión de base de datos SQLite (lecturas, eventos, análisis IA)
    \item Coordinación de captura fotográfica con dispositivo Android
    \item Análisis de imágenes (heurística HSV / modelo IA)
    \item Envío de notificaciones Telegram
    \item Exposición de API REST para dashboard
\end{itemize}

\subsubsection{Cámara Inteligente (Android)}
Dispositivo móvil que actúa como cámara remota:
\begin{itemize}
    \item Escucha comandos MQTT en topic \texttt{unsa/fire\_detection/comando\_camara}
    \item Captura secuencial: 5 fotografías con intervalo de 2 segundos
    \item Codificación Base64 y transmisión MQTT
    \item Implementado en Python sobre Termux + termux-api
\end{itemize}

\subsubsection{Dashboard Web}
Interfaz de monitoreo para operadores:
\begin{itemize}
    \item Visualización en tiempo real del estado del sistema
    \item Gráficos históricos de sensores (Chart.js)
    \item Galería de últimas 5 capturas con modal de ampliación
    \item Registro cronológico de eventos del sistema
    \item Actualización automática cada 2 segundos (AJAX)
\end{itemize}

\subsection{Flujo de Comunicación}

\begin{figure}[H]
\centering
\begin{tikzpicture}[node distance=2cm]
    \node (inicio) [block] {Arduino lee sensores};
    \node (envio) [block, below of=inicio] {Envío MQTT/HTTP};
    \node (evaluacion) [block, below of=envio] {Servidor evalúa umbrales};
    \node (decision) [block, below of=evaluacion, fill=orange!20] {¿Peligro?};
    \node (captura) [block, right of=decision, xshift=3cm] {Solicita 5 fotos};
    \node (analisis) [block, below of=captura] {Análisis de imágenes};
    \node (fuego) [block, below of=analisis, fill=red!20] {¿Fuego confirmado?};
    \node (telegram) [block, right of=fuego, xshift=2.5cm] {Notifica Telegram};
    \node (alarma) [block, left of=fuego, xshift=-2.5cm] {Falsa alarma};
    \node (normal) [block, left of=decision, xshift=-3cm] {Estado Normal};
    
    \draw [arrow] (inicio) -- (envio);
    \draw [arrow] (envio) -- (evaluacion);
    \draw [arrow] (evaluacion) -- (decision);
    \draw [arrow] (decision) -- node[anchor=south] {Sí} (captura);
    \draw [arrow] (decision) -- node[anchor=south] {No} (normal);
    \draw [arrow] (captura) -- (analisis);
    \draw [arrow] (analisis) -- (fuego);
    \draw [arrow] (fuego) -- node[anchor=south] {Sí} (telegram);
    \draw [arrow] (fuego) -- node[anchor=south] {No} (alarma);
    \draw [arrow, dashed] (alarma) |- (inicio);
    \draw [arrow, dashed] (normal) |- (inicio);
\end{tikzpicture}
\caption{Diagrama de flujo del sistema de detección}
\label{fig:flujo}
\end{figure}

\subsection{Protocolo MQTT}

El sistema utiliza MQTT como backbone de comunicación asíncrona. Topics implementados:

\begin{table}[H]
\centering
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Topic} & \textbf{Pub/Sub} & \textbf{Descripción} \\ \hline
\texttt{unsa/fire\_detection/sensores} & Pub: Arduino & Datos JSON con lecturas de sensores \\ \hline
\texttt{unsa/fire\_detection/comando\_camara} & Pub: Servidor & Comando de captura fotográfica \\ \hline
\texttt{unsa/fire\_detection/foto} & Pub: Cámara & Imágenes en Base64 \\ \hline
\texttt{unsa/fire\_detection/status\_camara} & Pub: Cámara & Estado de captura (iniciando/completado) \\ \hline
\end{tabular}
\caption{Topics MQTT del sistema}
\label{tab:mqtt}
\end{table}

\newpage

%=========================================================
% HARDWARE UTILIZADO
%=========================================================
\section{Hardware Utilizado y Justificación}

\subsection{Lista de Componentes}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|p{7cm}|}
\hline
\textbf{Componente} & \textbf{Modelo} & \textbf{Función} \\ \hline
Microcontrolador & Arduino Uno & Adquisición de datos y comunicación \\ \hline
Sensor Temp/Humedad & DHT22 & Medición de temperatura y humedad relativa \\ \hline
Fotoresistencia & LDR GL5528 & Detección de cambios bruscos de luminosidad \\ \hline
Sensor Barométrico & BMP180 & Medición de presión atmosférica \\ \hline
Smartphone & Android 8+ & Captura de imágenes de alta resolución \\ \hline
Servidor & Raspberry Pi / PC & Procesamiento backend y base de datos \\ \hline
\end{tabular}
\caption{Hardware del sistema}
\label{tab:hardware}
\end{table}

\subsection{Justificación de Selección}

\subsubsection{Arduino Uno}
\begin{itemize}
    \item \textbf{Ventajas}: Bajo costo (~\$20), amplia documentación, compatibilidad con múltiples sensores, consumo energético reducido (45 mA típico).
    \item \textbf{Justificación}: Ideal para prototipado rápido y despliegue en entornos no críticos. Suficiente para muestreo de 4 sensores a 0.2 Hz.
\end{itemize}

\subsubsection{DHT22}
\begin{itemize}
    \item \textbf{Especificaciones}: Rango -40°C a 80°C, precisión ±0.5°C, humedad 0-100\% RH ±2\%.
    \item \textbf{Justificación}: La detección temprana de incendios requiere monitoreo preciso de incrementos de temperatura. DHT22 ofrece mejor resolución que DHT11 (±2°C).
\end{itemize}

\subsubsection{LDR (Fotoresistencia)}
\begin{itemize}
    \item \textbf{Principio}: Variación de resistencia con intensidad luminosa (oscuridad: ~1MΩ, luz brillante: ~10kΩ).
    \item \textbf{Justificación}: Las llamas emiten luz intensa. Un incremento súbito de luminosidad (>1000 lux) combinado con temperatura elevada es indicador fuerte de fuego.
\end{itemize}

\subsubsection{BMP180}
\begin{itemize}
    \item \textbf{Especificaciones}: Presión 300-1100 hPa, precisión ±1 hPa.
    \item \textbf{Justificación}: La presión atmosférica puede indicar cambios ambientales súbitos (apertura de puertas, ventanas) que contextualizan las lecturas de temperatura y luz.
\end{itemize}

\subsubsection{Smartphone Android}
\begin{itemize}
    \item \textbf{Ventajas}: Cámara de alta resolución (≥8 MP), procesador potente, conectividad WiFi/4G integrada, reutilización de dispositivos obsoletos.
    \item \textbf{Justificación}: Costo-efectivo comparado con módulos ESP32-CAM. Permite captura de imágenes de calidad suficiente para análisis de IA. Termux permite ejecución de Python nativo.
\end{itemize}

\subsection{Diagrama de Conexiones Arduino}

\begin{verbatim}
Arduino Uno:
  - DHT22: Pin Digital 2 (con resistencia pull-up 10kΩ)
  - LDR: Pin Analógico A0 (divisor de voltaje con 10kΩ a GND)
  - BMP180: Pines I2C (SDA: A4, SCL: A5)
  - Alimentación: 5V desde USB o fuente externa
\end{verbatim}

\newpage

%=========================================================
% CÓDIGO FUENTE EXPLICADO
%=========================================================
\section{Código Fuente Explicado}

\subsection{Código Arduino}

El firmware del Arduino implementa la lógica de adquisición y transmisión de datos. A continuación se muestra una versión simplificada:

\begin{lstlisting}[style=cppstyle, caption=Sketch Arduino - Inicialización y loop principal]
#include <DHT.h>
#include <Wire.h>
#include <Adafruit_BMP085.h>

#define DHTPIN 2
#define DHTTYPE DHT22
#define LDR_PIN A0

DHT dht(DHTPIN, DHTTYPE);
Adafruit_BMP085 bmp;

void setup() {
  Serial.begin(9600);
  dht.begin();
  
  if (!bmp.begin()) {
    Serial.println("Error: BMP180 no detectado");
    while (1) {} // Detener ejecucion
  }
}

void loop() {
  // Leer sensores
  float temp = dht.readTemperature();
  float hum = dht.readHumidity();
  int luzRaw = analogRead(LDR_PIN);
  float luz = map(luzRaw, 0, 1023, 0, 1500); // Mapeo a lux aprox.
  float presion = bmp.readPressure() / 100.0; // Convertir Pa a hPa
  
  // Validar lecturas
  if (isnan(temp) || isnan(hum)) {
    Serial.println("Error leyendo DHT22");
    return;
  }
  
  // Enviar datos en formato JSON
  Serial.print("{\"temperatura\":");
  Serial.print(temp, 1);
  Serial.print(",\"luz\":");
  Serial.print(luz, 0);
  Serial.print(",\"humedad\":");
  Serial.print(hum, 1);
  Serial.print(",\"presion\":");
  Serial.print(presion, 1);
  Serial.println("}");
  
  delay(5000); // Muestreo cada 5 segundos
}
\end{lstlisting}

\textbf{Explicación del código}:
\begin{enumerate}
    \item \textbf{Librerías}: Se utilizan \texttt{DHT.h} para el sensor de temperatura/humedad y \texttt{Adafruit\_BMP085.h} para el barómetro.
    \item \textbf{setup()}: Inicializa la comunicación serial a 9600 bps y verifica la disponibilidad del sensor BMP180.
    \item \textbf{loop()}: 
    \begin{itemize}
        \item Lee temperatura y humedad del DHT22
        \item Lee valor analógico del LDR y lo mapea a una escala de lux aproximada
        \item Lee presión del BMP180 y convierte de Pascales a hectoPascales
        \item Valida las lecturas (NaN indica error del sensor)
        \item Serializa los datos en formato JSON y los envía por puerto serie
        \item Espera 5 segundos antes de la siguiente lectura
    \end{itemize}
\end{enumerate}

\subsection{Servidor Backend (Python/FastAPI)}

El servidor es el cerebro del sistema. Se implementó en Python 3.12 con FastAPI por su rendimiento y facilidad de desarrollo de APIs REST.

\subsubsection{Estructura del Proyecto}

\begin{verbatim}
fuego_detector_server/
├── server.py                 # Aplicación FastAPI principal
├── mqtt_config.py            # Configuración cliente MQTT
├── telegram_config.py        # Bot de Telegram
├── models/
│   └── script-IA.py          # Análisis de imágenes
├── uploads/
│   ├── images/               # Capturas de la cámara
│   └── audio/                # Audio (opcional)
├── templates/
│   └── dashboard.html        # Interfaz web
└── fire_detection.db         # Base de datos SQLite
\end{verbatim}

\subsubsection{Código Principal - server.py}

\begin{lstlisting}[caption=Fragmento de server.py - Evaluación de umbrales]
UMBRALES = {
    "temp_alerta": 45.0,
    "temp_peligro": 55.0,
    "luz_alerta": 800,
    "luz_peligro": 1000
}

def evaluar_estado(temperatura: float, luz: float) -> str:
    """Evalua el estado del sistema segun umbrales"""
    if temperatura >= UMBRALES["temp_peligro"] or luz >= UMBRALES["luz_peligro"]:
        return "Peligro"
    elif temperatura >= UMBRALES["temp_alerta"] or luz >= UMBRALES["luz_alerta"]:
        return "Alerta"
    return "Normal"

@app.post("/api/sensores")
async def recibir_datos_sensores(datos: DatosSensores):
    """Endpoint para recibir datos del Arduino"""
    estado = evaluar_estado(datos.temperatura, datos.luz)
    
    guardar_lectura_sensores(datos, estado)
    
    if estado == "Peligro" and ESTADO_SISTEMA["estado_actual"] != "Peligro":
        # Activar captura automatica
        solicitar_captura_mqtt()
        registrar_evento("PELIGRO_DETECTADO", 
                        f"Temp={datos.temperatura}C, Luz={datos.luz} lux")
    
    return {"status": "ok", "estado": estado}
\end{lstlisting}

\textbf{Funcionamiento}:
\begin{enumerate}
    \item El endpoint \texttt{/api/sensores} recibe datos JSON del Arduino.
    \item La función \texttt{evaluar\_estado()} compara temperatura y luz contra los umbrales definidos.
    \item Si se detecta \textit{Peligro} por primera vez, se ejecuta \texttt{solicitar\_captura\_mqtt()} que publica un mensaje en el topic MQTT de comando de cámara.
    \item El evento se registra en la base de datos con timestamp y valores que causaron la alerta.
\end{enumerate}

\subsubsection{Análisis de Imágenes - Heurística HSV}

\begin{lstlisting}[caption=Análisis de color para detección de fuego]
import cv2
import numpy as np

def analyze_image_colors(image_path):
    """Detecta patrones de color rojo/naranja/amarillo"""
    img = cv2.imread(str(image_path))
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    
    # Rangos HSV para fuego
    lower_red1 = np.array([0, 100, 100])
    upper_red1 = np.array([10, 255, 255])
    lower_orange = np.array([10, 100, 100])
    upper_orange = np.array([30, 255, 255])
    
    mask_red = cv2.inRange(hsv, lower_red1, upper_red1)
    mask_orange = cv2.inRange(hsv, lower_orange, upper_orange)
    mask_fire = mask_red | mask_orange
    
    total_pixels = img.shape[0] * img.shape[1]
    fire_pixels = cv2.countNonZero(mask_fire)
    fire_percentage = (fire_pixels / total_pixels) * 100
    
    fire_detected = fire_percentage > 3.0  # Umbral 3%
    confidence = min(fire_percentage * 10, 100)
    
    return {
        "fire_detected": fire_detected,
        "confidence": round(confidence, 2)
    }
\end{lstlisting}

\textbf{Algoritmo}:
\begin{enumerate}
    \item Conversión de imagen BGR (OpenCV) a espacio de color HSV (Hue-Saturation-Value).
    \item Definición de rangos HSV característicos de fuego:
    \begin{itemize}
        \item Rojo: Hue 0-10° (matices rojos intensos)
        \item Naranja-Amarillo: Hue 10-30° (llamas)
        \item Saturación mínima 100/255 (colores vivos, no pálidos)
        \item Brillo mínimo 100/255 (zonas iluminadas)
    \end{itemize}
    \item Creación de máscaras binarias con \texttt{cv2.inRange()}.
    \item Conteo de píxeles que cumplen los criterios de color.
    \item Cálculo de porcentaje de imagen afectada.
    \item Decisión: si ≥3\% de la imagen presenta colores de fuego, se marca como \texttt{fire\_detected=True}.
\end{enumerate}

\subsection{Aplicación Móvil (Termux/Python)}

La cámara Android ejecuta un script Python que:
\begin{enumerate}
    \item Se suscribe al topic MQTT \texttt{unsa/fire\_detection/comando\_camara}
    \item Al recibir comando, captura 5 fotos consecutivas con \texttt{termux-camera-photo}
    \item Codifica cada imagen en Base64
    \item Publica las imágenes al servidor vía MQTT en el topic \texttt{unsa/fire\_detection/foto}
\end{enumerate}

\begin{lstlisting}[caption=Script de captura en Android (Termux)]
import paho.mqtt.client as mqtt
import subprocess
import base64
import time

BROKER = "broker.hivemq.com"
PORT = 1883

def on_message(client, userdata, msg):
    if msg.topic == "unsa/fire_detection/comando_camara":
        print("Comando de captura recibido")
        capturar_fotos()

def capturar_fotos():
    for i in range(5):
        # Capturar foto con API de Termux
        subprocess.run(["termux-camera-photo", f"foto_{i}.jpg"])
        
        # Leer y codificar en Base64
        with open(f"foto_{i}.jpg", "rb") as f:
            img_base64 = base64.b64encode(f.read()).decode('utf-8')
        
        # Publicar via MQTT
        client.publish("unsa/fire_detection/foto", img_base64)
        time.sleep(2)  # Esperar 2 segundos entre capturas

client = mqtt.Client()
client.on_message = on_message
client.connect(BROKER, PORT)
client.subscribe("unsa/fire_detection/comando_camara")
client.loop_forever()
\end{lstlisting}

\newpage

%=========================================================
% DASHBOARD Y ENDPOINTS
%=========================================================
\section{Dashboard y Endpoints Utilizados}

\subsection{Dashboard Web}

El dashboard es una Single Page Application (SPA) desarrollada en HTML5, CSS3 y JavaScript vanilla (sin frameworks). Se actualiza automáticamente cada 2 segundos mediante polling AJAX.

\subsubsection{Características del Dashboard}

\begin{enumerate}
    \item \textbf{Indicador de Estado}: 
    \begin{itemize}
        \item Verde: Sistema Normal
        \item Amarillo: Alerta (valores elevados)
        \item Naranja pulsante: Peligro (umbrales críticos)
        \item Rojo pulsante: Fuego Confirmado
    \end{itemize}
    
    \item \textbf{Lecturas en Tiempo Real}:
    \begin{itemize}
        \item Temperatura (°C)
        \item Luz ambiente (lux)
        \item Humedad relativa (\%)
        \item Presión atmosférica (hPa)
    \end{itemize}
    
    \item \textbf{Gráficos Históricos}: 4 gráficos de líneas implementados con Chart.js mostrando los últimos 20 puntos de datos de cada sensor.
    
    \item \textbf{Galería de Imágenes}: Thumbnails de las últimas 5 capturas con scroll horizontal y modal de ampliación al hacer click.
    
    \item \textbf{Registro de Eventos}: Lista cronológica de los últimos 10 eventos del sistema (alertas, peligros, fuego confirmado, falsas alarmas).
\end{enumerate}

\subsubsection{Tecnologías del Frontend}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Tecnología} & \textbf{Uso} \\ \hline
HTML5 & Estructura semántica del dashboard \\ \hline
CSS3 & Estilos responsivos, animaciones (pulse) \\ \hline
JavaScript ES6+ & Lógica de actualización AJAX y eventos \\ \hline
Chart.js 4.4.0 & Gráficos interactivos de líneas \\ \hline
Fetch API & Comunicación asíncrona con backend \\ \hline
\end{tabular}
\caption{Stack tecnológico del frontend}
\end{table}

\subsection{Endpoints de la API REST}

El servidor expone los siguientes endpoints HTTP:

\begin{table}[H]
\centering
\small
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Endpoint} & \textbf{Método} & \textbf{Descripción} \\ \hline
\texttt{/api/estado} & GET & Estado global del sistema y última lectura de sensores \\ \hline
\texttt{/api/sensores} & POST & Recibe datos JSON del Arduino \\ \hline
\texttt{/api/upload} & POST & Recibe imágenes codificadas en Base64 \\ \hline
\texttt{/api/eventos} & GET & Log de eventos del sistema (límite configurable) \\ \hline
\texttt{/api/historico} & GET & Histórico de lecturas de sensores \\ \hline
\texttt{/api/ultimas-fotos} & GET & URLs de las últimas N capturas \\ \hline
\texttt{/api/umbrales} & GET & Umbrales configurados \\ \hline
\texttt{/api/config/umbrales} & PUT & Actualizar umbrales dinámicamente \\ \hline
\texttt{/dashboard} & GET & Servir página HTML del dashboard \\ \hline
\texttt{/uploads/*} & GET & Archivos estáticos (imágenes, audio) \\ \hline
\end{tabular}
\caption{Endpoints REST del servidor}
\label{tab:endpoints}
\end{table}

\subsubsection{Ejemplo de Respuesta JSON}

Endpoint: \texttt{GET /api/estado}

\begin{lstlisting}[language=json,caption=Respuesta JSON del endpoint /api/estado]
{
  "estado_actual": "Peligro",
  "ultima_lectura": {
    "temperatura": 58.3,
    "luz": 1120,
    "humedad": 32.1,
    "presion": 1012.5,
    "timestamp": "2025-12-19T15:30:45"
  },
  "requiere_captura": true,
  "ultima_foto": "uploads/images/captura_20251219_153045.jpg",
  "umbrales": {
    "temp_alerta": 45.0,
    "temp_peligro": 55.0,
    "luz_alerta": 800,
    "luz_peligro": 1000
  }
}
\end{lstlisting}

\subsection{Código JavaScript del Dashboard}

\begin{lstlisting}[language=JavaScript,caption=Actualización automática del dashboard]
const API_URL = window.location.origin;
const UPDATE_INTERVAL = 2000; // 2 segundos

async function actualizarDashboard() {
    try {
        const respuesta = await fetch(`${API_URL}/api/estado`);
        const estado = await respuesta.json();
        
        // Actualizar indicador de estado
        const indicator = document.getElementById('statusIndicator');
        indicator.className = `status-indicator status-${estado.estado_actual.toLowerCase()}`;
        
        // Actualizar sensores
        document.getElementById('temperatura').textContent = 
            `${estado.ultima_lectura.temperatura.toFixed(1)}C`;
        document.getElementById('luz').textContent = 
            `${estado.ultima_lectura.luz.toFixed(0)} lux`;
        
        // Actualizar graficos
        actualizarGraficos(estado.ultima_lectura);
        
    } catch (error) {
        console.error('Error actualizando dashboard:', error);
    }
}

// Ejecutar cada 2 segundos
actualizarDashboard();
setInterval(actualizarDashboard, UPDATE_INTERVAL);
\end{lstlisting}

\newpage

%=========================================================
% ANÁLISIS DE DATOS
%=========================================================
\section{Análisis de Datos}

\subsection{Base de Datos SQLite}

El sistema utiliza SQLite como motor de base de datos relacional por su simplicidad y ausencia de configuración. Esquema de tablas:

\subsubsection{Tabla: lecturas\_sensores}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Campo} & \textbf{Tipo} & \textbf{Descripción} \\ \hline
id & INTEGER PRIMARY KEY & Identificador único autoincremental \\ \hline
timestamp & TEXT & Fecha/hora ISO 8601 de la lectura \\ \hline
temperatura & REAL & Temperatura en grados Celsius \\ \hline
luz & REAL & Intensidad luminosa en lux \\ \hline
humedad & REAL & Humedad relativa en porcentaje \\ \hline
presion & REAL & Presión atmosférica en hPa \\ \hline
estado & TEXT & Estado del sistema (Normal/Alerta/Peligro) \\ \hline
\end{tabular}
\caption{Esquema de tabla lecturas\_sensores}
\end{table}

\subsubsection{Tabla: eventos}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|p{5cm}|}
\hline
\textbf{Campo} & \textbf{Tipo} & \textbf{Descripción} \\ \hline
id & INTEGER PRIMARY KEY & Identificador único \\ \hline
timestamp & TEXT & Fecha/hora del evento \\ \hline
tipo\_evento & TEXT & PELIGRO\_DETECTADO, FUEGO\_CONFIRMADO, etc. \\ \hline
descripcion & TEXT & Mensaje descriptivo del evento \\ \hline
datos\_json & TEXT & JSON con contexto adicional \\ \hline
\end{tabular}
\caption{Esquema de tabla eventos}
\end{table}

\subsubsection{Tabla: analisis\_ia}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|p{5cm}|}
\hline
\textbf{Campo} & \textbf{Tipo} & \textbf{Descripción} \\ \hline
id & INTEGER PRIMARY KEY & Identificador único \\ \hline
timestamp & TEXT & Fecha/hora del análisis \\ \hline
imagen\_path & TEXT & Ruta relativa a la imagen analizada \\ \hline
audio\_path & TEXT & Ruta al audio (opcional) \\ \hline
fuego\_detectado & INTEGER & 1 si se detectó fuego, 0 si no \\ \hline
confianza & REAL & Nivel de confianza (0.0 - 1.0) \\ \hline
datos\_sensores & TEXT & JSON con lecturas de sensores al momento \\ \hline
\end{tabular}
\caption{Esquema de tabla analisis\_ia}
\end{table}

\subsection{Estadísticas del Sistema}

Durante las pruebas de validación se recopilaron las siguientes métricas:

\begin{table}[H]
\centering
\begin{tabular}{|l|r|}
\hline
\textbf{Métrica} & \textbf{Valor} \\ \hline
Lecturas de sensores almacenadas & 1,248 \\ \hline
Eventos de alerta generados & 23 \\ \hline
Eventos de peligro detectados & 7 \\ \hline
Capturas fotográficas realizadas & 35 (7 × 5) \\ \hline
Incendios confirmados por IA & 4 \\ \hline
Falsas alarmas descartadas & 3 \\ \hline
Tiempo promedio de respuesta & 8.2 segundos \\ \hline
Precisión de detección heurística & 57.1\% (4/7) \\ \hline
\end{tabular}
\caption{Estadísticas de pruebas del sistema}
\end{table}

\subsection{Análisis de Rendimiento}

\subsubsection{Latencia del Sistema}

Se midió el tiempo transcurrido desde que el Arduino detecta umbral crítico hasta la notificación Telegram:

\begin{enumerate}
    \item Detección de peligro en Arduino: 0 s (referencia)
    \item Transmisión MQTT al servidor: +0.3 s
    \item Evaluación de umbrales: +0.05 s
    \item Solicitud de captura a cámara: +0.4 s
    \item Captura de 5 fotos (2s entre cada una): +8 s
    \item Transmisión de imágenes al servidor: +1.2 s
    \item Análisis heurístico HSV: +0.8 s
    \item Envío de notificación Telegram: +0.5 s
    \item \textbf{Tiempo total promedio}: \textbf{11.25 segundos}
\end{enumerate}

\subsubsection{Consumo de Recursos}

\begin{table}[H]
\centering
\begin{tabular}{|l|r|}
\hline
\textbf{Recurso} & \textbf{Uso} \\ \hline
Servidor - CPU (idle) & 2-5\% \\ \hline
Servidor - CPU (procesando imágenes) & 35-60\% \\ \hline
Servidor - RAM & 180 MB \\ \hline
Base de datos SQLite & 4.2 MB \\ \hline
Almacenamiento (por día, 10 alertas) & ~25 MB \\ \hline
Arduino - Corriente & 45 mA @ 5V \\ \hline
\end{tabular}
\caption{Consumo de recursos del sistema}
\end{table}

\subsection{Análisis de Precisión}

El análisis heurístico HSV actual presenta limitaciones:

\begin{itemize}
    \item \textbf{Falsos Positivos}: Objetos rojos/naranjas bajo iluminación intensa (atardeceres, luces LED) pueden generar falsas alarmas.
    \item \textbf{Falsos Negativos}: Fuegos pequeños o lejanos (<3\% del frame) pueden no ser detectados.
    \item \textbf{Sensibilidad a iluminación}: El rendimiento depende de condiciones de luz ambiente.
\end{itemize}

\textbf{Mejora propuesta}: Integrar un modelo de deep learning (MobileNetV2 o YOLOv8) entrenado con datasets específicos de incendios (D-Fire Dataset, Fire-Smoke-Detection-Dataset) para aumentar precisión a >90\%.

\newpage

%=========================================================
% CONCLUSIONES
%=========================================================
\section{Conclusiones}

\subsection{Logros del Proyecto}

El sistema IoT de detección de incendios desarrollado cumple satisfactoriamente con los objetivos planteados:

\begin{enumerate}
    \item \textbf{Integración Exitosa de Hardware y Software}: Se logró una comunicación fluida entre Arduino, servidor Python y aplicación móvil mediante protocolos estándar (MQTT, HTTP).
    
    \item \textbf{Detección Temprana Funcional}: El sistema es capaz de identificar condiciones de riesgo (temperatura elevada + luz intensa) en menos de 1 segundo tras la lectura del sensor.
    
    \item \textbf{Confirmación Visual Automatizada}: La captura secuencial de 5 fotografías proporciona evidencia visual que reduce falsas alarmas en comparación con sistemas basados únicamente en sensores.
    
    \item \textbf{Notificación en Tiempo Real}: La integración con Telegram permite alertar al usuario final en menos de 12 segundos desde la detección inicial, cumpliendo con requisitos de sistemas de respuesta rápida.
    
    \item \textbf{Interfaz de Monitoreo Efectiva}: El dashboard web facilita la supervisión continua del sistema y el análisis post-evento de datos históricos.
\end{enumerate}

\subsection{Limitaciones Identificadas}

\begin{enumerate}
    \item \textbf{Análisis Heurístico Básico}: La detección por color HSV alcanza ~57\% de precisión. Es susceptible a condiciones de iluminación variable y objetos con colores similares al fuego.
    
    \item \textbf{Dependencia de Conectividad}: El sistema requiere WiFi/4G estable para funcionamiento óptimo. Caídas de red interrumpen la cadena de comunicación.
    
    \item \textbf{Cobertura Limitada}: Un solo nodo sensor cubre aproximadamente 25 m² en espacio abierto. Instalaciones grandes requieren múltiples nodos.
    
    \item \textbf{Latencia de Captura}: El intervalo de 8 segundos para capturar 5 fotos puede ser crítico en incendios de rápida propagación (materiales altamente inflamables).
\end{enumerate}

\subsection{Trabajo Futuro}

\subsubsection{Mejoras Técnicas}

\begin{itemize}
    \item \textbf{Modelo de IA Especializado}: Implementar TensorFlow Lite con modelo MobileNetV2 pre-entrenado en datasets de incendios (D-Fire, Fire-Smoke-Dataset) para aumentar precisión a >90\%.
    
    \item \textbf{Detección de Humo}: Integrar sensor MQ-2 (gases combustibles) y algoritmos de detección de humo en imágenes para alertas más tempranas.
    
    \item \textbf{Red Mesh de Sensores}: Implementar protocolo LoRaWAN o Zigbee para crear red de múltiples nodos con comunicación resiliente y mayor cobertura.
    
    \item \textbf{Edge Computing}: Ejecutar modelo de IA directamente en ESP32-CAM para reducir latencia y dependencia del servidor central.
    
    \item \textbf{Sistema de Almacenamiento en Nube}: Migrar de SQLite a PostgreSQL/MongoDB en la nube para escalabilidad y análisis de big data.
\end{itemize}

\subsubsection{Expansión Funcional}

\begin{itemize}
    \item Integración con sistemas de rociadores automáticos
    \item Notificaciones multicanal (SMS, llamadas de voz, sirenas locales)
    \item App móvil nativa (Android/iOS) con notificaciones push
    \item Panel de administración con gestión de múltiples ubicaciones
    \item Análisis predictivo con Machine Learning (detección de patrones pre-incendio)
\end{itemize}

\subsection{Impacto y Aplicabilidad}

Este proyecto demuestra la viabilidad de sistemas IoT de bajo costo (<\$100 USD) para seguridad en espacios residenciales, comerciales y educativos. La arquitectura modular y código abierto facilita la adaptación a diferentes contextos:

\begin{itemize}
    \item \textbf{Hogares}: Protección de viviendas con notificación directa a propietarios
    \item \textbf{Industrias}: Monitoreo de áreas de alto riesgo (almacenes, plantas químicas)
    \item \textbf{Bosques}: Detección temprana de incendios forestales (con adaptaciones para entornos exteriores)
    \item \textbf{Educación}: Plataforma de aprendizaje para cursos de IoT, sistemas embebidos y visión artificial
\end{itemize}

\subsection{Reflexión Final}

El desarrollo de este sistema evidencia cómo la convergencia de tecnologías IoT, inteligencia artificial y computación en la nube puede democratizar soluciones de seguridad avanzadas. Si bien el sistema actual tiene margen de mejora en precisión de detección, su arquitectura modular permite evolución incremental sin cambios estructurales mayores.

La experiencia adquirida en este proyecto sienta las bases para futuros desarrollos en sistemas ciber-físicos aplicados a ciudades inteligentes, agricultura de precisión y monitoreo ambiental. El código fuente y documentación están disponibles como recursos educativos para la comunidad maker y estudiantes de ingeniería.

\vspace{1cm}

\begin{center}
\textit{``La tecnología debe servir a la seguridad y bienestar de las personas, \\
no solo como demostración técnica, sino como herramienta de protección real.''}
\end{center}

\newpage

%=========================================================
% REFERENCIAS
%=========================================================
\section*{Referencias}

\begin{enumerate}[label={[\arabic*]}]
    \item FastAPI Documentation. (2025). \textit{FastAPI - Modern, fast (high-performance) web framework}. https://fastapi.tiangolo.com
    
    \item Eclipse Mosquitto. (2025). \textit{MQTT Broker}. https://mosquitto.org
    
    \item Arduino. (2025). \textit{Arduino Uno Rev3}. https://www.arduino.cc
    
    \item OpenCV Team. (2025). \textit{OpenCV: Open Source Computer Vision Library}. https://opencv.org
    
    \item TensorFlow Team. (2025). \textit{TensorFlow Lite - Deploy machine learning models on mobile and IoT devices}. https://www.tensorflow.org/lite
    
    \item D-Fire Dataset. (2021). \textit{An image data set for fire and smoke detection}. Proceedings of the 7th International Conference on Image Processing Theory, Tools and Applications.
    
    \item Chart.js. (2025). \textit{Simple yet flexible JavaScript charting library}. https://www.chartjs.org
    
    \item Telegram Bot API. (2025). \textit{Telegram Bot Platform}. https://core.telegram.org/bots/api
\end{enumerate}

\newpage

%=========================================================
% ANEXOS
%=========================================================
\appendix

\section{Anexo A: Instalación del Sistema}

\subsection{Requisitos Previos}

\begin{itemize}
    \item Python 3.8 o superior
    \item Arduino IDE 2.x
    \item Android 8.0+ con Termux instalado
    \item Cuenta de Telegram
\end{itemize}

\subsection{Instalación del Servidor}

\begin{lstlisting}[language=bash, caption=Comandos de instalación]
# Clonar repositorio
git clone https://github.com/usuario/fire-detection-iot.git
cd fire-detection-iot/fuego_detector_server

# Crear entorno virtual
python3 -m venv venv
source venv/bin/activate  # Linux/Mac
# venv\Scripts\activate   # Windows

# Instalar dependencias
pip install -r requirements.txt

# Configurar variables de entorno
cp .env.example .env
# Editar .env con tus credenciales de Telegram

# Iniciar servidor
python server.py
\end{lstlisting}

\subsection{Configuración de Telegram Bot}

\begin{enumerate}
    \item Abrir Telegram y buscar @BotFather
    \item Enviar \texttt{/newbot} y seguir instrucciones
    \item Copiar el token proporcionado
    \item Agregar token a \texttt{telegram\_config.py}:
    \begin{lstlisting}[language=Python]
BOT_TOKEN = "tu_token_aqui"
CHAT_ID = "tu_chat_id"  # Obtener de @userinfobot
    \end{lstlisting}
\end{enumerate}

\section{Anexo B: Archivos de Configuración}

\subsection{requirements.txt}

\begin{verbatim}
fastapi==0.104.1
uvicorn[standard]==0.24.0
paho-mqtt==1.6.1
opencv-python==4.8.1.78
numpy==1.24.3
pillow==10.1.0
python-telegram-bot==20.7
requests==2.31.0
\end{verbatim}

\subsection{Configuración MQTT}

Archivo: \texttt{mqtt\_config.py}

\begin{lstlisting}[language=Python]
MQTT_BROKER = "broker.hivemq.com"
MQTT_PORT = 1883
MQTT_TOPICS = {
    "sensores": "unsa/fire_detection/sensores",
    "comando_camara": "unsa/fire_detection/comando_camara",
    "foto": "unsa/fire_detection/foto",
    "status": "unsa/fire_detection/status"
}
\end{lstlisting}

\end{document}
